$date
	Fri Nov 06 13:08:07 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$var wire 8 ! progbyte [7:0] $end
$var wire 4 " operand [3:0] $end
$var wire 4 # instr [3:0] $end
$var reg 1 $ clock $end
$var reg 1 % enF $end
$var reg 1 & enP $end
$var reg 1 ' load $end
$var reg 12 ( load_1 [11:0] $end
$var reg 1 ) reset $end
$scope module MF $end
$var wire 1 $ clock $end
$var wire 1 % enF $end
$var wire 1 & enP $end
$var wire 1 ' load $end
$var wire 12 * load_1 [11:0] $end
$var wire 1 ) reset $end
$var wire 8 + progbyte [7:0] $end
$var wire 4 , operand [3:0] $end
$var wire 4 - instr [3:0] $end
$var wire 12 . counter [11:0] $end
$scope module COUNT $end
$var wire 1 $ clock $end
$var wire 1 & en $end
$var wire 1 ' load $end
$var wire 12 / load_1 [11:0] $end
$var wire 1 ) reset $end
$var reg 12 0 count [11:0] $end
$upscope $end
$scope module FTCH $end
$var wire 1 $ clock $end
$var wire 1 % en $end
$var wire 1 ) reset $end
$var wire 8 1 D [7:0] $end
$var reg 4 2 instr [3:0] $end
$var reg 4 3 operand [3:0] $end
$upscope $end
$scope module ROM $end
$var wire 12 4 address [11:0] $end
$var wire 8 5 palabra [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
x)
bx (
x'
x&
x%
x$
bx #
bx "
bx !
$end
#1
b0 (
b0 *
b0 /
0'
0&
0%
0$
0)
#2
b1 !
b1 +
b1 1
b1 5
b0 .
b0 0
b0 4
b0 #
b0 -
b0 2
b0 "
b0 ,
b0 3
1)
#3
0)
#5
1$
#10
0$
#15
1$
#20
0$
#21
b1010101 !
b1010101 +
b1010101 1
b1010101 5
b1010101 .
b1010101 0
b1010101 4
b1 "
b1 ,
b1 3
b1010101 (
b1010101 *
b1010101 /
1'
1&
1%
#25
b101 #
b101 -
b101 2
b101 "
b101 ,
b101 3
1$
#27
b1010110 !
b1010110 +
b1010110 1
b1010110 5
b1010110 .
b1010110 0
b1010110 4
b0 (
b0 *
b0 /
0'
#30
0$
#35
b1010111 !
b1010111 +
b1010111 1
b1010111 5
b1010111 .
b1010111 0
b1010111 4
b110 "
b110 ,
b110 3
1$
#40
0$
#45
b1011000 !
b1011000 +
b1011000 1
b1011000 5
b1011000 .
b1011000 0
b1011000 4
b111 "
b111 ,
b111 3
1$
#46
